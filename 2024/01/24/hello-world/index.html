<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="false" > 
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  

  
  <title>2024 新年的印记-寒假 OI 训练 | Cuiyi_SAI&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="preload" href="/css/fonts/Roboto-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
  <link rel="preload" href="/css/fonts/Roboto-Bold.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <meta name="description" content="$1-24$ P1309 [NOIP2011 普及组] 瑞士轮 $\small{对排序算法的理解}$  $\large{\text{Solution}}:$  挺有意思的一题，原先按照题意模拟考虑轮用一次 $\text{sort}$ 没想到时限太紧 $\color{darkblue} T$ 了（ $O(R\cdot n\log n)$ 确实慢），但是根据题解的思想直接把 $\text{sort}$">
<meta property="og:type" content="article">
<meta property="og:title" content="2024 新年的印记-寒假 OI 训练">
<meta property="og:url" content="http://cuiyisai.github.io/2024/01/24/hello-world/index.html">
<meta property="og:site_name" content="Cuiyi_SAI&#39;s blog">
<meta property="og:description" content="$1-24$ P1309 [NOIP2011 普及组] 瑞士轮 $\small{对排序算法的理解}$  $\large{\text{Solution}}:$  挺有意思的一题，原先按照题意模拟考虑轮用一次 $\text{sort}$ 没想到时限太紧 $\color{darkblue} T$ 了（ $O(R\cdot n\log n)$ 确实慢），但是根据题解的思想直接把 $\text{sort}$">
<meta property="og:locale">
<meta property="og:image" content="https://s1.ax1x.com/2018/09/30/ilT4sS.gif">
<meta property="article:published_time" content="2024-01-23T16:00:00.000Z">
<meta property="article:modified_time" content="2024-02-03T08:02:52.596Z">
<meta property="article:author" content="Cuiyi_SAI">
<meta property="article:tag" content="OI 生涯">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2018/09/30/ilT4sS.gif">
  
    <link rel="alternate" href="/atom.xml" title="Cuiyi_SAI's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.jpg">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  
   
  <div id="main-grid" class="  ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>Cuiyi_SAI's blog </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">首页</a>
    
      <a class="main-nav-link" href="/archives">印记</a>
    
      <a class="main-nav-link" href="/about">关于我</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="light-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M438.5-829.913v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-829.913Zm0 747.826v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-82.087ZM877.913-438.5h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537t29.476-12.174h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T877.913-438.5Zm-747.826 0h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T82.087-521.5h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T130.087-438.5Zm660.174-290.87-34.239 32q-12.913 12.674-29.565 12.174-16.653-.5-29.327-13.174-12.674-12.673-12.554-28.826.12-16.152 12.794-28.826l33-35q12.913-12.674 30.454-12.674t30.163 12.847q12.709 12.846 12.328 30.826-.38 17.98-13.054 30.653ZM262.63-203.978l-32 34q-12.913 12.674-30.454 12.674t-30.163-12.847q-12.709-12.846-12.328-30.826.38-17.98 13.054-30.653l33.239-31q12.913-12.674 29.565-12.174 16.653.5 29.327 13.174 12.674 12.673 12.554 28.826-.12 16.152-12.794 28.826Zm466.74 33.239-32-33.239q-12.674-12.913-12.174-29.565.5-16.653 13.174-29.327 12.673-12.674 28.826-13.054 16.152-.38 28.826 12.294l35 33q12.674 12.913 12.674 30.454t-12.847 30.163q-12.846 12.709-30.826 12.328-17.98-.38-30.653-13.054ZM203.978-697.37l-34-33q-12.674-12.913-13.174-29.945-.5-17.033 12.174-29.707t31.326-13.293q18.653-.62 31.326 13.054l32 34.239q11.674 12.913 11.174 29.565-.5 16.653-13.174 29.327-12.673 12.674-28.826 12.554-16.152-.12-28.826-12.794ZM480-240q-100 0-170-70t-70-170q0-100 70-170t170-70q100 0 170 70t70 170q0 100-70 170t-170 70Zm-.247-82q65.703 0 111.475-46.272Q637-414.544 637-480.247t-45.525-111.228Q545.95-637 480.247-637t-111.475 45.525Q323-545.95 323-480.247t45.525 111.975Q414.05-322 479.753-322ZM481-481Z"/></svg></span>
      <span class="dark-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M480.239-116.413q-152.63 0-258.228-105.478Q116.413-327.37 116.413-480q0-130.935 77.739-227.435t206.304-125.043q43.022-9.631 63.87 10.869t3.478 62.805q-8.891 22.043-14.315 44.463-5.424 22.42-5.424 46.689 0 91.694 64.326 155.879 64.325 64.186 156.218 64.186 24.369 0 46.978-4.946 22.609-4.945 44.413-14.076 42.826-17.369 62.967 1.142 20.142 18.511 10.511 61.054Q807.174-280 712.63-198.206q-94.543 81.793-232.391 81.793Zm0-95q79.783 0 143.337-40.217 63.554-40.218 95.793-108.283-15.608 4.044-31.097 5.326-15.49 1.283-31.859.805-123.706-4.066-210.777-90.539-87.071-86.473-91.614-212.092-.24-16.369.923-31.978 1.164-15.609 5.446-30.978-67.826 32.478-108.282 96.152Q211.652-559.543 211.652-480q0 111.929 78.329 190.258 78.329 78.329 190.258 78.329ZM466.13-465.891Z"/></svg></span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/atom.xml" title="RSS Feed">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M198-120q-25.846 0-44.23-18.384-18.384-18.385-18.384-44.23 0-25.846 18.384-44.23 18.384-18.385 44.23-18.385 25.846 0 44.23 18.385 18.384 18.384 18.384 44.23 0 25.845-18.384 44.23Q223.846-120 198-120Zm538.385 0q-18.846 0-32.923-13.769-14.076-13.769-15.922-33.23-8.692-100.616-51.077-188.654-42.385-88.039-109.885-155.539-67.5-67.501-155.539-109.885Q283-663.462 182.385-672.154q-19.461-1.846-33.23-16.23-13.769-14.385-13.769-33.846t14.076-32.922q14.077-13.461 32.923-12.23 120.076 8.692 226.038 58.768 105.961 50.077 185.73 129.846 79.769 79.769 129.846 185.731 50.077 105.961 58.769 226.038 1.231 18.846-12.538 32.922Q756.461-120 736.385-120Zm-252 0q-18.231 0-32.423-13.461t-18.653-33.538Q418.155-264.23 348.886-333.5q-69.27-69.27-166.501-84.423-20.077-4.462-33.538-18.961-13.461-14.5-13.461-33.346 0-19.076 13.884-33.23 13.884-14.153 33.115-10.922 136.769 15.384 234.384 112.999 97.615 97.615 112.999 234.384 3.231 19.23-10.538 33.115Q505.461-120 484.385-120Z"/></svg>
      </a>
    
    <div id="nav-menu-btn" class="nav-icon">
      <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M177.37-252.282q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Zm0-186.218q-17.453 0-29.477-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T177.37-521.5h605.26q17.453 0 29.477 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T782.63-438.5H177.37Zm0-186.217q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Z"/></svg>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">首页</a>
    
      <a class="nav-dropdown-link" href="/archives">印记</a>
    
      <a class="nav-dropdown-link" href="/about">关于我</a>
    
    
      <a class="nav-dropdown-link" href="/atom.xml" title="RSS Feed">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=/favicon.jpg></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">Cuiyi_SAI </div>
      <div class="dot"></div>
      <div class="subtitle">人只有醒来后才知道自己睡了一觉 </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://www.luogu.com.cn/user/488775" title="luogu"><i class="fa-solid fa-laptop-code""></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/2013005981?spm_id_from=333.1007.0.0" title="bilibili"><i class="fa-brands fa-bilibili"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/CuiyiSAI" title="GitHub"><i class="fa-brands fa-github"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      



    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Tags</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/OI-%E7%94%9F%E6%B6%AF/" rel="tag">OI 生涯</a></li></ul>
    </div>
  </div>


    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       


<article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        2024 新年的印记-寒假 OI 训练
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2024-01-23T16:00:00.000Z" itemprop="datePublished">2024-01-24</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
    Uncategorized 
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            5.7k words 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OI-%E7%94%9F%E6%B6%AF/" rel="tag">OI 生涯</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <h2 id="1-24"><a href="#1-24" class="headerlink" title="$1-24$"></a>$1-24$</h2><p> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1309" title="P1309 [NOIP2011 普及组] 瑞士轮">P1309 [NOIP2011 普及组] 瑞士轮</a></p>
<p>$\small{对排序算法的理解}$ </p>
<p>$\large{\text{Solution}}:$ </p>
<p>挺有意思的一题，原先按照题意模拟考虑轮用一次 $\text{sort}$ 没想到时限太紧 $\color{darkblue} T$ 了（ $O(R\cdot n\log n)$ 确实慢），但是根据题解的思想直接把 $\text{sort}$ 换成 $\text{stable_sort}$ 居然过了？？？<br>题解思路，考虑胜者每轮都 $+1$ ，负者每轮都不变，因此 胜者所在的集合内部 和 负者所在的集合内部 分数的相对大小关系是不变的，都是有序的。因此问题转化成了将胜负二者这两个<strong>有序数列合并</strong>的问题，可以采用 $O(n)$ 的归并排序中的方法来合并，总体复杂度 $O(R\cdot n)$。</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1083" title="P1083 [NOIP2012 提高组] 借教室">P1083 [NOIP2012 提高组] 借教室</a></p>
<p>$\small{二分加速枚举、线段树、若干水法}$</p>
<p>$\large{\text{Solution1}}:$ </p>
<p>可以发现每次区间操作后这段区间的数都会变得更小，因此若一次操作后区间序列不合法（有数字 $&lt;0$）那么之后的所有操作序列都不再合法；同理，若一次操作后序列仍合法，那么这个操作前的序列也必定合法。这就满足了二分的局部舍弃性（或者是单调性？），可以用一个二分来加速操作的枚举。<br>具体的，对于每一个 $\text{mid}$ ， 都判断执行了 $\text{mid}$ 个操作后序列是否合法，以此二分。</p>
<p>$\large{\text{Solution2}}:$ </p>
<p>先处理出完成 $m$ 次操作的序列，然后 $1-n$ 扫一遍，若当前数 $&lt;0$ 那么将操作<strong>从后往前</strong>依次撤回，直到整个序列都合法，那么最后一次撤回的操作即为答案。</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3612" title="P3612 [USACO17JAN] Secret Cow Code S">P3612 [USACO17JAN] Secret Cow Code S</a></p>
<p>$\small{递归（分治）}$</p>
<p>$\large{\text{Solution}}:$ </p>
<p>可以看出每次操作后的字符串后半部分与上一次的字符串基本一样，所以我们就考虑用这个来递归，每次都会缩小一半的长度。<br>具体的，若 $n&lt;\frac{len}{2}$，那么后半部分是没用的，直接 $len/2$；若 $n&gt;\frac{len}{2}$ ，那么位置 $n$ 是由上一个串的位置 $n-1-len/2$ 翻转得到，递归处理这个子问题即可。</p>
<hr>
<h2 id="1-25"><a href="#1-25" class="headerlink" title="$1-25$"></a>$1-25$</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1199" title="P1199 [NOIP2010 普及组] 三国游戏">P1199 [NOIP2010 普及组] 三国游戏</a></p>
<p>$贪心，带一点博弈论？$<br>思考加代码总用时约 1 小时，代码错误：局部变量未初始化，导致UB。</p>
<p>$\large{\text{Solution}}:$ </p>
<p>不管我们开局选哪个武将 $x$，和他默契度最高的武将 $y$ 一定会被电脑抢走。但是默契度次大的武将 $z$ 我们必然可以取到。因此，全部武将对应默契<strong>次大值的最大值</strong>即为我们的最优解，同时我们根据机器策略的盲目性，显然可以主动的避免让机器取得优于我们的解，因此<strong>人类必胜</strong>。</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2672">P2672 [NOIP2015 普及组] 推销员</a></p>
<p>$贪心$<br>刚开始想了10+分钟有了接近正解的思路，但是没有沉住气继续深入思考就直接开始 coding，导致接下来硬钢 90 分钟无果，然后继续深入思考后想出正解，10分钟写完代码。</p>
<p>$\large{\text{Solution1}}:$ </p>
<p>显然 $x=n$ 时答案是易得的，而转移到 $n-1$ 只需删除一个对答案贡献最小的数即可。因此本题使用倒推，维护每个数的贡献，然后每次小根堆删除最小的即可。因为要删数，所以我们还需要一个链表维护前一个数 $lst_i$ 和后一个数 $nxt_i$。<br>考虑 $i$ 的贡献：若 $S_i$ 不是当前未删数字的最大值，那么 $S_i$ 对答案没有贡献，此时 $i$ 的贡献<br>为 $a_i$；若 $S_i$ 是最大值，那么删除掉 $i$ 会使得答案失去 $S_i-S_{lst_i}$  这一段，所以此时 $i$ 的贡献为 $2\cdot(S_i-S_{lst_i})+a_i$。由于每一次删数都有可能导致 $S_i$ 的最大值改变，而且 $lst_i$ 也在变，因此在删的过程中还有进一步维护每个数的贡献。</p>
<p>$\large{\text{Solution2}}:$ </p>
<blockquote>
<p>距离很烦，所以我们先不考虑距离 ——题解</p>
</blockquote>
<p>选 $x$ 个，最贪心的想，按照 $a$ 排序选前 $x$ 大的那几个。其次，我们可以通过将其中的一个（显然也<strong>只</strong>需要一个）换成另一个 $S$ 更大的数，也就是用 $a$ 的贡献换取 $S$ 的贡献，也可能让答案更优。至于用哪个来换呢，显然使用最小的，也就是第 $x$ 大的来换。</p>
<p><strong>这题确实挺不错的。</strong></p>
<hr>
<h2 id="1-26"><a href="#1-26" class="headerlink" title="$1-26$"></a>$1-26$</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF743C" title="Vladik and fractions">Vladik and fractions</a></p>
<p>$数学，构造$<br>找到了解题的关键但是没有深入思考，导致20分钟后宣告失败，遂看题解。</p>
<p>$\large{\text{Solution}}:$ </p>
<blockquote>
<p>三个变量让我很不喜欢，所以考虑先干掉一个</p>
</blockquote>
<p>注意到 $\dfrac{2}{n}$ 的这个 $2$ 似乎别有用意，于是尝试把它拆成 $\dfrac{1}{n}+\dfrac{1}{n}$，原式变为</p>
<script type="math/tex; mode=display">
\dfrac{1}{x}+\dfrac{1}{y}+\dfrac{1}{z}=\dfrac{1}{n}+\dfrac{1}{n}</script><p>不妨直接令 $z=n$，则问题化为求</p>
<script type="math/tex; mode=display">
\dfrac{1}{x}+\dfrac{1}{y}=\dfrac{1}{n}</script><p>然后就是<strong>小学奥数</strong> $\dfrac{1}{n+1}+\dfrac{1}{n(n+1)}=\dfrac{1}{n}$ 结束。</p>
<p>闲话：实在太菜了，做黄色的构造题都觉得好难QAQ</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_agc032_a" title="[AGC032A] Limited Insertion">[AGC032A] Limited Insertion</a></p>
<p>$构造$<br>AGC 的题目果然不一般，非常有趣，思路中的细节值得深入思考。思考20分钟无果，遂看题解。</p>
<p>$\large{\text{Solution}}:$ </p>
<p>考虑什么时候无解：一个数 $a$ 肯定是在位置 $a$ 处插入，而往后的插入操作每次都会把一部分数往后推，因此最终序列 $b$ 有 $b_i\le i$，否则无解。<br>最后一次插入是容易的，肯定是一个数 $i$ 插入到了位置 $i$ 上。于是我们<strong>从后往前</strong>找到第一个 $b_i=i$ 的数，那么他就是最后一次插入操作，把它撤销后序列就变成了上一次操作时的，就变成了子问题，继续找即可。<br>为什么要从后往前呢？考虑若有 $b_x=x,b_y=y,x<y$ ，若我们选择撤销 $x$ 处的插入的话，那么 $x$ 后面所有的数都要往前挪一个， 也就有 $b_{y-1}=y>y-1$ ，也就是一开始说的无解的情况。所以要从后往前找。</p>
<p>还是没做出黄题，寄。</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_agc032_b" title="[AGC032B] Balanced Neighbors">[AGC032B] Balanced Neighbors</a></p>
<p>$图论，构造$<br>在草稿纸上模拟了10分钟就想出来了，大概是构造一个各部分权值和相同的完全 $k$ 分图（参加OI-wiki），算是比较友好的题了。<br>题解的思路非常有参考价值。</p>
<p>$\large{\text{Solution}}:$ </p>
<blockquote>
<p> 若无向图（无重边无自环）$G$ 不连通，则它的补图 $G’$ 联通。</p>
</blockquote>
<p>上述结论的证明 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/264756166" title="在这里">在这里</a></p>
<p>我们构造一个图，使得此图</p>
<ul>
<li>不连通</li>
<li>对于图上的任意顶点，<strong>该点</strong>和与该点相连的点编号和均为定值 $S$</li>
</ul>
<p>那么这张图的补图就满足</p>
<ul>
<li>连通</li>
<li>对于图上的任意顶点，与该点相连的点编号和均为定值</li>
</ul>
<p>可见满足了题目要求。<br>具体的，我们将 $n$ 分奇偶讨论：<br>若 $n$ 为奇数，那么我们将连接 $(1,n-1),(2,n-2)\cdots$ ，$n$ 单独一点。输出补图即可。<br>若 $n$ 为偶数，我们连接 $(1,n),(2,n-1)\cdots$，输出补图即可。</p>
<hr>
<p>看到了个有趣的 $trick$：不降原则——枚举的时候有序枚举，保证序列不降，可以去重</p>
<hr>
<h2 id="1-27"><a href="#1-27" class="headerlink" title="$1-27$"></a>$1-27$</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1514" title="P1514 [NOIP2010 提高组] 引水入城">P1514 [NOIP2010 提高组] 引水入城</a></p>
<p>$记忆化搜索，贪心$<br>记搜部分水爆了，但是第二问的前提性质还是挺有思考价值的，证出来以后贪心就做完了。</p>
<p>$\large{\text{Solution}}:$ </p>
<p>无解的情况搜索的时候直接判掉就好了，下面只考虑有解的情况。</p>
<p>性质：蓄水池能到的干旱地区一定是<strong>一个区间</strong><br>证明的话可以用反证法巴拉巴拉胡一下，大概就是两条不同的路径必有交叉，因此能输水的地方必定连续（没有图不好描述）<br>记搜的时候就把蓄水池能到的区间左右端点记下来即可，然后第二问就变成了一个区间覆盖整条线段问题，贪心即可。<br>具体的，将区间按照左端点排序，每次选都选一个<strong>左端点在已覆盖范围内且右端点最远的区间</strong>来更新。<a target="_blank" rel="noopener" href="https://blog.csdn.net/yl_puyu/article/details/109682733" title="参考">参考</a></p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1120" title="P1120 小木棍">P1120 小木棍</a></p>
<p>$搜索剪枝$<br>没写，但是其中有一个剪枝非常巧妙。<br>因该是最优化剪枝的一种，思想就是若当前操作是<strong>最优的但还是失败了</strong>，那就没必要继续往后尝试了，回溯到以前即可。<br>具体到本题，就是若选上当前木棍恰好能凑出一根完整木棍（这个操作显然是所有可选操作中最优的），但是往后搜索还是失败了，那就没必要继续尝试用别的木棍凑这根原始木棍了，回溯到上一层。</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3067" title="P3067 [USACO12OPEN] Balanced Cow Subsets G">P3067 [USACO12OPEN] Balanced Cow Subsets G</a></p>
<p>$Meet<del>in</del>middle$，$bitset$<br>非常暴力的思路，思考加coding反反复复一共花了90min，最后用bitset直接贴着最优解的脸。<br>看了一下题解，思路很巧妙（果然我太蠢了），但是貌似并没有我快（普遍做法 1s，我的做法 200ms）</p>
<p>$\large{\text{Solution1}}:$ </p>
<p>很暴力的思想，先枚举子集，然后再枚举子集的划分！</p>
<p>数据规模很小但是暴搜又过不了，于是可以考虑折半<del>暴搜</del>搜索。直接把序列分成左右两半，然后分别dfs选子集。</p>
<p>考虑左半部分选出了子集 $A$，将它分为两部分和分别为 $a$，$b$，右半部分选出了子集 $B$，将它分为两部分和分别为 $c$，$d$ ，若两个子集的并为 $C$ ，要使 $C$ 合法则应有 $a+c=b+d$，移项可得 $a-b=d-c$ 。</p>
<p>这就给我们折半后合并答案提供了思路：我们选定出子集后同样暴力搜索出它的划分方案，称两部分权值的差为 $A-B$，然后用一个 $set$ （当然是为了去重）记录下每个集合所有可能划分的 $A-B$ 的值，合并时利用 $set$ 保存的信息，判断有多少个左右集合的<strong>某个</strong> $A-B$ 值相同，这些是对答案有贡献的。<br>具体实现有一点复杂，使用了 bitset 来去重，跑得飞快。</p>
<p>$\large{\text{Solution2}}:$ </p>
<p>题解巧妙的做法在于：每个数有三种状态，一种是不选，一种是放入1队，最后是放入2队，一个dfs就可以 $O(3^n)$。<br>果然比我的先枚举子集，再枚举子集中的划分这种两<strong>层</strong>dfs要清新多了，统计答案的时候也是记录 $A-B$ ，也是将子集二进制压缩来去重（我用的是bitset），感觉大差不差，不知道为什么有些题解比我慢那么多。</p>
<hr>
<h2 id="1-28"><a href="#1-28" class="headerlink" title="$1-28$"></a>$1-28$</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1020" title="P1020 [NOIP1999 提高组] 导弹拦截">P1020 [NOIP1999 提高组] 导弹拦截</a></p>
<p>$\large{\text{Solution}}:$ </p>
<p>LIS 中用二分维护的 d 数组的意义是维护对于每个DP值得最优转移，比如说求不升子序列的时候，将 $a_i$ 接在一个<strong>恰好</strong> 大于他的位置是最优的（小了不行，大太多也浪费），而可以证明这个最优的位置是单调的，因此可以二分维护。</p>
<p>主要就是这什么 $Dilworth$ 定理：在偏序集中，最小链划分数等于最大反链的长度。<br>说人话就是，将一个序列划分为多个不相交的不升子序列，最小划分数是这个序列最长上升子序列的长度。</p>
<hr>
<h2 id="1-29-amp-30"><a href="#1-29-amp-30" class="headerlink" title="$1-29~\&amp;~30$"></a>$1-29~\&amp;~30$</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/S-A-I/p/17995383" title="USACO真好玩，快乐银组">USACO真好玩，快乐银组</a></p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4158" title="P4158 [SCOI2009] 粉刷匠">P4158 [SCOI2009] 粉刷匠</a></p>
<p>众所周知，蓝色是水的颜色，这就是一道DP翻译题。（指把题意翻译成DP的转移就过了）</p>
<p>$\large{\text{Solution}}:$ </p>
<p>每个木头相互独立，而每个格子只能涂一次，因此不难想到把他们设入状态。<br>设 $f_{i,j,k,0/1/2}$ 表示涂了 $j$ 次涂到第 $i$ 块木板的第 $k$ 格时，涂 $0$ 或 $1$ 或不涂的最大正确数。<br>然后就有了显而易见的转移，只需要分讨填到第 $k$ 个的时候的决策即可（翻译题目）。</p>
<script type="math/tex; mode=display">
f_{i,j,k,0}=\max\left(f_{i,j,k-1,0}~,~f_{i,j-1,k-1,1}~,~f_{i,j-1,k-1,2}\right)+(a_{i,j}==0)\\
f_{i,j,k,1}=\max\left(f_{i,j,k-1,1}~,~f_{i,j-1,k-1,0}~,~f_{i,j-1,k-1,2}\right)+(a_{i,j}==1)\\
f_{i,j,k,2}=\max\left(f_{i,j,k-1,0}~,~f_{i,j,k-1,1}~,~f_{i,j,k-1,2}\right)</script><p>特别的,有初值</p>
<script type="math/tex; mode=display">
f_{i,j,0,2}=\max\left(f_{i-1,j,m,0},f_{i-1,j,m,1},f_{i-1,j,m,2}\right)</script><p>大水，建议降绿</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P9498" title="P9498 「RiOI-2」equals">P9498 「RiOI-2」equals</a></p>
<p>$贪心，构造$<br>半年前月赛里的黄题，不会做，现在还是不会做，果然我一点没有长进。评价是该死的贪心。</p>
<p>$\large{\text{Solution}}:$ </p>
<p>首先求出每个节点的深度，若深度和 $sum$ 为奇数显然无解。</p>
<p>问题可以转化为选出某些节点，使其深度和恰好等于 $\dfrac{sum}{2}$。考虑到本题一个很重要的性质：因为在树上，因此<strong>深度在值域上是连续的。</strong>，注意到这一点就可以<del>很容易</del>想到<strong>必定</strong>是凑出 $\dfrac{sum}{2}$。<br>具体的，我们贪心从大到小扫过去，若可以选就选上，否则找更小的补。</p>
<p>当然如果直接写一个暴搜程序，<strong>加上从大到小的排序</strong>也是<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/discuss/652967" title="能过">能过</a>的，因为大的数太僵硬不好分配所以先选，小的数灵活可以尽可能满足条件。这个操作可以非常有效的减小搜索树的规模。</p>
<hr>
<h2 id="1-31"><a href="#1-31" class="headerlink" title="$1-31$"></a>$1-31$</h2><p>月末，遇到了一道神仙题，这道题警示我不要在一个困难的思路上死磕，要像广搜一样，接受一些悦动的新灵感，或许会有不一样的收获。<br><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2501" title="P2501 [HAOI2006] 数字序列 题解">P2501 [HAOI2006] 数字序列 题解</a></p>
<p>$DP+找性质$<br>sb题调了3个小时，确实神仙细节也确实多：(</p>
<p>$\large{\text{Solution}}:$ </p>
<p>先看第一问，要求最少改变多少个，其实不太好下手（但是我还是下手了，硬写了快1小时的DP，真蠢啊），考虑补集转化，其实就是求最多保留多少个。手玩一下数据找找性质可以发现，因为要求最后要<strong>严格</strong>上升，所以<strong>若 $a_i-a_j&lt;i-j$，那么 $a_i$ 和 $a_j$ 不能都保留</strong>，因为无法改变他两中间的那些数使得这个区间上升（中间数字太多，可用数字太少）。所以设 $f_i$ 表示保留 $i$ 则 $1$ 到 $i$ 中最多能保留多少个数，易得</p>
<script type="math/tex; mode=display">
f_i=\min\limits_{j<i}f_j+1~~~~~~~(a_i-a_j\ge i-j)</script><p>但是如果把限制移一下项，就会得到 $a_i-i\ge a_j-j$，若设 $b_i=a_i-i$，那么上述转移就是在求 $b$ 的<strong>最长不下降子序列</strong>！恭喜你找到本题的性质之一，可以愉快的用 $O(n\log n)$ 做掉第一问。<br>获得成就：得到 $b$ 数组。</p>
<p>现在看第二问，显然修改 $a_i$ 和修改 $b_i$ 是等价的，因此就转化为了<strong>用最小的修改代价使得 $b$ 单调不降</strong>。<br>需要修改的显然是不在最长不降子序列中的数。若 $b_i~,~b_j~(j<i)$ **在**最长不降子序列中 且 **在子序列中的位置相邻**，那么 $\forall k\in(i,j),b_k<b_j ~or ~ b_k>b_i$。修改这些 $k$ 后为了使区间不降，肯定会在值域上形成一段阶梯，考虑如何调整这段阶梯使得代价最小。<br><img src="https://s1.ax1x.com/2018/09/30/ilT4sS.gif" alt=""></p>
<p>由图可知且<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/solution/P2501" title="可以证明">可以证明</a>任何最小代价的阶梯样式一定能被转换为上图所示的 ⌊ 存在一个划分点 $k\in[i,j]$，使得 $\forall l\in[i,k],b_l=b_i~and~\forall l \in (k,j],b_l=b_j$ ⌉ 的形式。<br>因此我们只需要枚举分界点 $k$ 即可找到最小代价。<br>需要注意，最长不降子序列可能有多个，因此最终求答案的过程还需 DP。设 $g_i$ 表示保持 $b_i$ 不变，使得 $[1,i]$ 不降的最小代价。若 $b_i$ 在最长不降子序列中的前一个数是 $pre_i$ （显然，$pre_i$ 可能不是 1 个数），那么有</p>
<script type="math/tex; mode=display">
g_i=\min\limits_{p\in pre_i}\left(g_p+\min\limits_{k\in [p,i)}\left(\sum\limits_{l=p+1}^k|b_l-b_p|+\sum\limits_{l=k+1}^{i-1}|b_l-b_i|\right)\right)</script><p>利用前缀和和数据随机的特性，该算法为 $O(n^2)$ 。</p>
<p>实现细节就非常有东西了，因为正常情况下最长不降子序列的左右两边都可能有数，因此我们要将 $b_0$ 和 $b_{n+1}$ 分别做最小和最大处理，将他们也纳入不降序列当中。其中，$b_0$ 不能直接设成0，因为 $b_i$ 的值域可以达到 $-n$（两个小时的 experience）。</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2946" title="P2946 [USACO09MAR] Cow Frisbee Team S">P2946 [USACO09MAR] Cow Frisbee Team S</a></p>
<p>$\large{\text{Solution}}:$ </p>
<p>考虑从限制入手，要让所选数的和为 $F$ 的倍数，形式化的转换一下就是 $\bmod F=0$，因此可以想到把 $\bmod F$ 写入状态，然后就是一个选与不选的DP方程了。</p>
<hr>
<p>若有代价和价值以及一个限制，那么考虑背包。<br>背包是一种对（代价，价值）二元关系的合并方式，因此树上DP对子树的合并也即是背包。</p>
<hr>
<h2 id="2-1"><a href="#2-1" class="headerlink" title="$2-1$"></a>$2-1$</h2><p>又打了<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/contest/124637#problems" title="一场比赛">一场比赛</a>，遇见了一道有趣的题。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P10118" title="P10118 『STA - R4』And">P10118 『STA - R4』And</a></p>
<p>$\large{\text{Solution}}:$ </p>
<p>二进制好题。<br>在题解里学会了一个好用的玩意</p>
<script type="math/tex; mode=display">
x+y=2\cdot(x~\&~y)+x~\operatorname{xor}~y</script><p>所以题目就转化为了找 $x~\operatorname{xor}~y=A-2B$，按二进制位考虑，就能发现除最高位有贡献外其他位都是互补没有贡献的，然后这题就做完了。思路即清爽又引人深思，痛快！</p>
<p>然后这场比赛的T3教会我：如果实在调不出来，那就<strong>尽早写对拍，否则调死你！</strong><br>铭记哀痛：2.5h+ 调分块最终 0 分！</p>
<hr>
<p>若最优解可以通过<strong>合并</strong>得到，且时间允许，可以考虑区间DP。<br>区间DP的答案会和区间有关，这里的区间是广义的。</p>
<hr>
<h2 id="2-2"><a href="#2-2" class="headerlink" title="$2-2$"></a>$2-2$</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2014#submit" title="P2014 [CTSC1997] 选课">P2014 [CTSC1997] 选课</a></p>
<p>树上背包的其实可以理解为dp套dp，因为首先是父节点由子节点合并这一dp操作，其中又蕴含了背包的划分思想——每个子树都有代价和价值，因此合并子树就是 01 分组背包。</p>
<p>但是树上背包的复杂度真的玄学啊，上下界优化正在学习中……</p>
<hr>
<p>开始学一些不一定用得上的数学。</p>
<p>排序不等式（大小搭配乘不如大配大小配小）：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&若~a_1\le a_2\le a_3\le\cdots\le a_n，b_1\le b_2\le b_3\le\cdots\le b_n\\
&则~\sum\limits_{i=1}^n a_ib_{n-i+1} \le \sum\limits_{i=1}^na_ib_j\le\sum\limits_{i=1}^na_ib_i，其中 j 是 n 的一个排列
\end{aligned}</script><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Balbooa/article/details/79474829" title="详细证明">详细证明</a><br>接下来介绍一道与之相关的好题（可能 dp 的占比更大一点？）</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2647" title="P2647 最大收益">P2647 最大收益</a><br>神题。</p>
<p>考虑选择了 $s$ 物品，<strong>所选的第 $i$ 个物品</strong>的价值为 $W_i$，代价为 $R_i$，那么收益为</p>
<script type="math/tex; mode=display">
\sum\limits_{i=1}^sW_i-\sum\limits_{i=1}^s(s-i)R_i</script><p>在选取的物品一样的话，要使收益最大的选取顺序就应该使得 $\sum\limits_{i=1}^s(s-i)R_i$ 这部分最小，将其拆开</p>
<script type="math/tex; mode=display">
s\sum\limits_{i=1}^sR_i-\sum\limits_{i=1}^siR_i</script><p>显然只有后半部分跟选取顺序有关，因此考虑将他最大化，那么总体就最小。不难发现这就是排序不等式所支持的形式，当 $R_i$ 递增时取最大。以上就是我们贪心思路的数学证明，按照 $R$ 递增的顺序来取可以使得在取得物品相同时受益最大。</p>
<p>接下来就是这题精彩的 DP 了。<br>按照 $R$ 递增的顺序，我们尝试设 $f_i$ 表示考虑了前 $i$ 个得到的最大收益，但这样是不行的，因为 $R_i$ 对答案的影响与选了多少个相关。因此我们要将状态升维，设 $f_{i,j}$ 表示考略了前 $i$ 个取了 $j$ 个的最大收益。但还是不行，因为 $R_i$ 带来的影响与<strong>未来</strong>的决策选了多少个有关，我们无法在阶段 $i$ 的时候就知道，也就是说这么设状态是有后效性的，无法转移。<br>由前往后没有办法了，但可以发现 $R_i$ 只会对 $i$ 往后的数的选取造成影响，而对以前没有关系。貌似是一种无前效性？于是我们<strong>逆向思维</strong>，由后往前：设 $f_{i,j}$ 表示以 $i$ 为第一个往后选了 $j$ 个的最大收益，那么这时 $R_i$ 的影响就是 $R_i\cdot(j-1)$ 了。所以我们这样子倒着 DP，就解决了后效性的问题。</p>
<script type="math/tex; mode=display">
f_{i,j}=\max\left(f_{i+1,j},f_{i+1,j-1}+W_i-R_i\cdot\left(j-1\right)\right)</script><p>至此本题结 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2014" title="这题">这题</a></p>
<p>说实话，当在题解看到逆向DP的那一刻，有一种颅内高潮的感觉。这不禁令我联想到了在<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2365" title="这道题">这道题</a>所初见的那个名叫 “费用提前” 的DP优化技巧，令我觉得两者有着莫名的联系。当时就想，这题能不能也用费用提前来做呢？答案是否定的，因为费用提前的前提是 <strong>当前决策对未来的影响只与当前决策有关</strong>。而反观本题，$R_i$ 的影响是和后续的决策相关的，因此我认为不能用费用提前来做（当然，这种逆向DP 的方式我觉得就很像费用提前）。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LittleTwoawa/p/17220583.html" title="这里埋个伏笔">这里埋个伏笔</a>，以后一定要去学！</p>
<hr>
<p>原来树上背包这种合并蕴含着这么多东西！上下界优化他来了！</p>
<p>还是拿出 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2014" title="这题">这题</a>，普通的树上背包是这么写的：</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,v,w;i&lt;g[x].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">	  v=g[x][i].id;</span><br><span class="line">	  <span class="built_in">dp</span>(v);</span><br><span class="line">	  <span class="keyword">for</span>(<span class="type">int</span> j=m+(!x);j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">	    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;j;k++)</span><br><span class="line">	      f[x][j]=<span class="built_in">max</span>(f[x][j],f[v][k]+f[x][j-k]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>显然这份代码对于每个节点都要 $O(nm)$，加上搜索遍历总复杂度为 $O(n^2m)$。但是我们其实枚举了很多不必要的状态：</p>
<p>若已经合并了的大小为 $S$，$sze_x$ 表示以 $x$ 为根的子树大小。</p>
<ol>
<li>对于 $f_{u,j}$，若 $j&gt;S+sze_u$ 则是无意义的。</li>
<li>对于 $f_{u,j-k}$，若 $j-k&gt;S\iff k&lt;j-S$ 则是无意义的。</li>
<li>对于 $f_{v,k}$，若 $k&gt;sze_v$ 则是无意义的。</li>
</ol>
<p>我们根据上述调整 $j$，$k$ 的枚举范围，就被成为上下界优化。最终代码是这样的：</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    sze[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])&#123;</span><br><span class="line">        <span class="built_in">dp</span>(v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">min</span>(m+!u,sze[u]+sze[v]);j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="built_in">max</span>(<span class="number">1</span>,j-sze[u]);k&lt;j&amp;&amp;k&lt;=sze[v];k++)&#123;</span><br><span class="line">                f[u][j]=<span class="built_in">max</span>(f[u][j],f[u][j-k]+f[v][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sze[u]+=sze[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>小编也很难相信，但是事实就是如此，这份代码的复杂度上界骤然变成了 $O(n^2)$ 的了！<br>因为每次转移实际上都是两两子树合并的过程，也可以点对点合并的过程。经过上下界优化，所有不必要的状态和转移都被省去了<strong>，对于任意点对 $(a,b)$ 只可能在它们的 $\operatorname{lca}$ 处被合并一次</strong>，因此复杂度上界就是 $O(n^2)$ 的了。</p>
<p>但是我们看代码循环处还对 $m$ 取了 $min$，因此复杂度应该跟 $m$ 也有关系。事实上当 $m$ 小于 $n$ 的规模时，<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/le0n/guan-yu-shu-xing-bei-bao-fu-za-du-di-zheng-ming" title="可以证明">可以证明</a>，这个 dp 的复杂度是 $O(nm)$ 的。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/U53204" title="这">这</a> 是一道针对上下界优化的题，也非常神，卡得非常紧。这里面还有一个 trick，因为直接开二维数组会 MLE，因此直接<strong>把二维拍成一维</strong>的就可以减少很多原本不必要的空间。</p>
<hr>

        
      </div>

         
    </div>
    
     
  </div>
  
    

  
</article>






    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2024 Cuiyi_SAI<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn hide" onclick="topFunction()">
        <i class="fa-solid fa-angle-up"></i>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.classList.remove('hide')
        } else {
            btn.classList.add('hide')
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
</body>
</html>
